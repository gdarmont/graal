/*
 * Copyright (c) 2022, 2022, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.oracle.svm.core.sampler;

import java.lang.management.ManagementFactory;
import java.util.Arrays;
import java.util.List;

import org.graalvm.compiler.api.replacements.Fold;
import org.graalvm.compiler.options.Option;
import org.graalvm.nativeimage.ImageSingletons;
import org.graalvm.nativeimage.Isolate;
import org.graalvm.nativeimage.IsolateThread;
import org.graalvm.nativeimage.Platform;
import org.graalvm.nativeimage.Platforms;
import org.graalvm.nativeimage.StackValue;
import org.graalvm.nativeimage.c.function.CodePointer;
import org.graalvm.nativeimage.hosted.Feature;
import org.graalvm.word.Pointer;
import org.graalvm.word.UnsignedWord;

import com.oracle.svm.core.IsolateListenerSupport;
import com.oracle.svm.core.RegisterDumper;
import com.oracle.svm.core.VMInspectionOptions;
import com.oracle.svm.core.annotate.AutomaticFeature;
import com.oracle.svm.core.annotate.Uninterruptible;
import com.oracle.svm.core.code.CodeInfo;
import com.oracle.svm.core.code.CodeInfoAccess;
import com.oracle.svm.core.code.CodeInfoTable;
import com.oracle.svm.core.graal.nodes.WriteCurrentVMThreadNode;
import com.oracle.svm.core.graal.nodes.WriteHeapBaseNode;
import com.oracle.svm.core.heap.VMOperationInfos;
import com.oracle.svm.core.jdk.RuntimeSupport;
import com.oracle.svm.core.jdk.management.ManagementFeature;
import com.oracle.svm.core.jdk.management.SubstrateThreadMXBean;
import com.oracle.svm.core.jfr.JfrFeature;
import com.oracle.svm.core.option.RuntimeOptionKey;
import com.oracle.svm.core.stack.JavaFrameAnchor;
import com.oracle.svm.core.stack.JavaFrameAnchors;
import com.oracle.svm.core.stack.JavaStackWalker;
import com.oracle.svm.core.thread.JavaVMOperation;
import com.oracle.svm.core.thread.ThreadListenerFeature;
import com.oracle.svm.core.thread.ThreadListenerSupport;
import com.oracle.svm.core.thread.VMThreads;

@AutomaticFeature
@SuppressWarnings("unused")
class SubstrateSigprofHandlerFeature implements Feature {

    @Override
    public boolean isInConfiguration(IsInConfigurationAccess access) {
        return VMInspectionOptions.AllowVMInspection.getValue() && SubstrateSigprofHandler.isProfilingSupported();
    }

    @Override
    public List<Class<? extends Feature>> getRequiredFeatures() {
        return Arrays.asList(ThreadListenerFeature.class, JfrFeature.class, ManagementFeature.class);
    }

    @Override
    public void beforeAnalysis(BeforeAnalysisAccess access) {
        if (!ImageSingletons.contains(SubstrateSigprofHandler.class)) {
            /* No sigprof handler. */
            return;
        }

        /* Create stack visitor. */
        ImageSingletons.add(ProfilerStackWalkVisitor.class, new ProfilerStackWalkVisitor());

        /* Add listeners. */
        ThreadListenerSupport.get().register(new ProfilerThreadLocal());
        IsolateListenerSupport.singleton().register(new ProfilerIsolateLocal());

        /* Add startup hook. */
        RuntimeSupport.getRuntimeSupport().addStartupHook(new SubstrateSigprofHandlerStartupHook());
    }
}

final class SubstrateSigprofHandlerStartupHook implements RuntimeSupport.Hook {
    @Override
    public void execute(boolean isFirstIsolate) {
        if (isFirstIsolate) {
            SubstrateSigprofHandler.singleton().install();
        }
    }
}

/**
 * <p>
 * The core class of low overhead async sampling based <b>profiler</b>.
 * {@link SubstrateSigprofHandler} handles the periodic signal generated by the OS with given time
 * frequency.
 * </p>
 *
 * <p>
 * The asynchronous nature of signal means that:
 * <ol>
 * <li>signal handler can be called at any time (could be during GC, VM operation, uninterruptible
 * code).</li>
 * <li>signal handler can only execute certain code i.e. the calls that are async signal safe.</li>
 * </ol>
 * </p>
 * <p>
 * The signal handler is divided into three part:
 * <ol>
 * <li>Restore the isolate, isolate thread, stack and instruction pointers.</li>
 * <li>Prepare everything necessary for stack walk.</li>
 * <li>Do a stack walk and collect IPs into buffer.</li>
 * </ol>
 * </p>
 * 
 * <p>
 * The signal handler is as a <b>producer</b>. On the other side of relation is
 * {@link com.oracle.svm.core.jfr.JfrRecorderThread} that is <b>consumer</b>.
 * </p>
 *
 * <p>
 * The buffer ({@link ProfilerBuffer}) that we are using in this consumer-producer communication has
 * next traits:
 * <ul>
 * <li>allocated eagerly, in a part of the heap that is not accessible via GC.</li>
 * <li>there is always more available buffers that threads.</li>
 * </ul>
 * </p>
 * 
 * <p>
 * The communication between consumer and producer goes as follow:
 * <ul>
 * <li>Producer
 * <ul>
 * <li>pops the buffer from the pool of available buffers, the buffer now becomes thread-local.</li>
 * <li>write the IPs into buffer.</li>
 * <li>if the buffer is full, move it to a pool with buffers that awaits processing.</li>
 * </ul>
 * </li>
 * <li>Consumer
 * <ul>
 * <li>pops the buffer from the pool of full buffers.</li>
 * <li>reconstruct the stack walk based on IPs.</li>
 * <li>push the buffer into list of available buffers.</li>
 * </ul>
 * </li>
 * </ul>
 * <b>NOTE:</b> The producer and consumer are always accessing different buffer.
 * </p>
 *
 * <p>
 * In some rare cases, the profiling is impossible e.g. no available buffers in the pool, unknown IP
 * during stack walk, the thread is holding the pool's lock and the signal arrives etc.
 * </p>
 * 
 * @see ProfilerSpinLock
 * @see ProfilerBufferStack
 */
public abstract class SubstrateSigprofHandler {

    public static class Options {
        @Option(help = "Allow sampling-based profiling. Default: disabled in execution.")//
        static final RuntimeOptionKey<Boolean> SamplingBasedProfiling = new RuntimeOptionKey<>(Boolean.FALSE);
    }

    private boolean enabled;
    private final ProfilerBufferStack availableBuffers;
    private final ProfilerBufferStack fullBuffers;
    private SubstrateThreadMXBean threadMXBean;

    @Platforms(Platform.HOSTED_ONLY.class)
    protected SubstrateSigprofHandler() {
        this.availableBuffers = new ProfilerBufferStack();
        this.fullBuffers = new ProfilerBufferStack();
    }

    @Fold
    public static SubstrateSigprofHandler singleton() {
        return ImageSingletons.lookup(SubstrateSigprofHandler.class);
    }

    @Fold
    public static ProfilerStackWalkVisitor visitor() {
        return ImageSingletons.lookup(ProfilerStackWalkVisitor.class);
    }

    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
    public static boolean isProfilingEnabled() {
        return singleton().enabled;
    }

    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
    public static ProfilerBufferStack availableBuffers() {
        return singleton().availableBuffers;
    }

    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
    public static ProfilerBufferStack fullBuffers() {
        return singleton().fullBuffers;
    }

    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
    public static SubstrateThreadMXBean getSubstrateThreadMXBean() {
        return singleton().threadMXBean;
    }

    @Fold
    public static boolean isProfilingSupported() {
        return Platform.includedIn(Platform.LINUX.class);
    }

    /**
     * Installs the platform dependent sigprof handler.
     */
    public void install() {
        if (Options.SamplingBasedProfiling.getValue()) {
            threadMXBean = (SubstrateThreadMXBean) ManagementFactory.getThreadMXBean();
            /* Call VM operation to initialize the profiler and the threads. */
            InitializeProfilerOperation initializeProfilerOperation = new InitializeProfilerOperation();
            initializeProfilerOperation.enqueue();

            /* After the VM operations finishes. Install handler and start profiling. */
            install0();
        }
    }

    protected abstract void install0();

    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
    public abstract UnsignedWord createThreadLocalKey();

    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
    public abstract void setThreadLocalKeyValue(UnsignedWord key, IsolateThread value);

    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
    public abstract IsolateThread getThreadLocalKeyValue(UnsignedWord key);

    /** Is sigprof handler called from native code? */
    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
    private static boolean isIPInJavaCode(RegisterDumper.Context uContext) {
        Pointer ip = (Pointer) RegisterDumper.singleton().getIP(uContext);
        CodeInfo codeInfo = CodeInfoTable.getImageCodeInfo();
        Pointer codeStart = (Pointer) CodeInfoAccess.getCodeStart(codeInfo);
        UnsignedWord codeSize = CodeInfoAccess.getCodeSize(codeInfo);
        return ip.aboveOrEqual(codeStart) && ip.belowOrEqual(codeStart.add(codeSize));
    }

    /**
     * Walk the current stacktrace using isolate thread local area and isolate heap base.
     */
    @Uninterruptible(reason = "The method executes during signal handling.", callerMustBe = true)
    private static void doUninterruptibleStackWalk(RegisterDumper.Context uContext, boolean isIPInJavaCode) {
        CodePointer ip;
        Pointer sp;
        if (isIPInJavaCode) {
            ip = (CodePointer) RegisterDumper.singleton().getIP(uContext);
            sp = (Pointer) RegisterDumper.singleton().getSP(uContext);
        } else {
            JavaFrameAnchor anchor = JavaFrameAnchors.getFrameAnchor();
            if (anchor.isNull()) {
                /*
                 * The anchor is still null if the function is interrupted during prologue. See:
                 * com.oracle.svm.core.graal.snippets.CFunctionSnippets.prologueSnippet
                 */
                return;
            }

            ip = anchor.getLastJavaIP();
            sp = anchor.getLastJavaSP();

            if (ip.isNull() || sp.isNull()) {
                /*
                 * It can happen that anchor is in list of all anchors, but its IP and SP are not
                 * filled yet.
                 */
                return;
            }
        }

        /* Initialize stack walk. */
        ProfilerSampleWriterData data = StackValue.get(ProfilerSampleWriterData.class);
        if (prepareStackWalk(data)) {
            /* Walk the stack. */
            if (JavaStackWalker.walkCurrentThread(sp, ip, visitor())) {
                ProfilerSampleWriter.commit(data);
            }
        }
    }

    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
    private static boolean prepareStackWalk(ProfilerSampleWriterData data) {
        if (availableBuffers().getLock().isOwner() || fullBuffers().getLock().isOwner()) {
            /*
             * The current thread already holds the stack lock, so we can't access it. It's way
             * better to lose one sample, then potentially the whole buffer.
             */
            ProfilerThreadLocal.increaseMissedSamples();
            return false;
        }

        ProfilerBuffer buffer = ProfilerThreadLocal.getThreadLocalBuffer();
        if (buffer.isNull()) {
            /* Pop first free buffer from the pool. */
            buffer = SubstrateSigprofHandler.availableBuffers().popBuffer();
            if (buffer.isNull()) {
                /* No available buffers on the pool. Fallback! */
                ProfilerThreadLocal.increaseMissedSamples();
                return false;
            }
            ProfilerThreadLocal.setThreadLocalBuffer(buffer);
        }

        /* Initialize the buffer. */
        data.setProfilerBuffer(buffer);
        data.setStartPos(buffer.getPos());
        data.setCurrentPos(buffer.getPos());
        data.setEndPos(ProfilerBufferAccess.getDataEnd(buffer));
        ProfilerThreadLocal.setWriterData(data);
        return true;
    }

    /** Called from the platform dependent sigprof handler to enter isolate. */
    @Uninterruptible(reason = "The method executes during signal handling.", callerMustBe = true)
    protected static void tryEnterIsolateAndDoWalk(RegisterDumper.Context uContext) {
        /* Write isolate pointer (heap base) into register. */
        Isolate isolate = ProfilerIsolateLocal.getIsolate();
        WriteHeapBaseNode.writeCurrentVMHeapBase(isolate);

        /* We are keeping reference to isolate thread inside OS thread local area. */
        UnsignedWord key = ProfilerIsolateLocal.getKey();
        IsolateThread thread = SubstrateSigprofHandler.singleton().getThreadLocalKeyValue(key);
        if (thread.isNull()) {
            /* Thread is not yet initialized or already detached from isolate. */
            return;
        }

        /* Write isolate thread pointer into register. */
        WriteCurrentVMThreadNode.writeCurrentVMThread(thread);

        /* Check if the instruction pointer (IP) is inside native or java code. */
        boolean isIPInJavaCode = isIPInJavaCode(uContext);

        /* Walk the stack. */
        doUninterruptibleStackWalk(uContext, isIPInJavaCode);
    }

    private class InitializeProfilerOperation extends JavaVMOperation {

        protected InitializeProfilerOperation() {
            super(VMOperationInfos.get(InitializeProfilerOperation.class, "Initialize Profiler", SystemEffect.SAFEPOINT));
        }

        @Override
        protected void operate() {
            initialize();
        }

        /**
         * We need to ensure that all threads are properly initialized at a moment when we start a
         * profiling.
         */
        @Uninterruptible(reason = "Prevent pollution of the current thread's thread local JFR buffer.")
        private void initialize() {
            enabled = true;
            /*
             * Iterate all over all thread and initialize the thread-local storage of each thread.
             */
            for (IsolateThread thread = VMThreads.firstThread(); thread.isNonNull(); thread = VMThreads.nextThread(thread)) {
                ProfilerThreadLocal.initialize(thread);
            }
        }
    }
}
